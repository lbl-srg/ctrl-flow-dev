# Modelica-JSON Parser

This document outlines the structure and strategy of the modelica-json parser. The parser generates a normalized data set containing nodes of information about modelica-templates

## Modelica-JSON and Parser Strategy

Modelica-JSON is a complete representation of the modelica grammar. The linkage parser is narrowly focused on extracting information relevant to modelica templates, and generating a format consumable by the front-end (FE) interpreter.

## Structure

```
|------------------------------|
|          modelica            | <-- original Templates
|------------------------------|
|        modelica-json         | <-- generated by modelica-json tool
|------------------------------|
|           Element            | <-- Classes to wrap each declaration in modelica-json
|------------------------------|
|          Template            | <-- Helper class that interacts with `Element`s to extract linkage schema
|------------------------------|
|        Linkage-Schema        | <-- format consumable by FE interpreter
|------------------------------|

```

### Modelica-JSON

The Modelieca-JSON format behaves a lot like an abstract syntax tree. Features of the modelica language are represented in JSON, and interpretting those features is a required behavior for the parser and FE.

This includes:

- evaluating type references
-

### Element

Each type and parameter definition gets extracted as an `Element`. There are several types of `Element`s based on the declaration type. As each

```modelica
within ExamplePackage "An Example Package"
model ExampleModel "An Example Model"
    extends ExampleExtendModel;

    parameter Example.Component component(
        componentParam=5
        )
        "An example param that is a component instance";

    parameter String id
        "An example literal parameter";

```

The above modelica generates the following elements:

1. `model ExampleModel "An Example Model"`

This creates an `Element` of type `InputGroup`. An `InputGroup` is an element that has child elements (in this case it has three: the referenced extended class `ExampleExtendModel`, `component`, and `id`)

This elements gets put in the type store at the path: `ExamplePackage.ExampleModel`

2. `extends ExampleExtendModel`

`Extend` statements in modelica are effectively treated as an additional parameter on a model. An implicit parameter name of `__extend` is given. There is a unique type for extend classes `InputGroupExtend`.

`InputGroup`s have a reference to `InputGroupExtend` instance (in this case `ExampleModel` has a reference to `ExampleExtendModel`). The behavior required to 'flatten' inherited properties is taken care of in the `InputGroup` implementation.

This extend element get added to the type store with the following path: `ExamplePackage.ExampleModel.__extend`. This is a purely internal reference that is not exposed in linkage schema (and is likely not necessary since input groups hold onto a reference to the `InputGroupExtend` reference).

3.  '''
    parameter Example.Component component(
    componentParam=5
    )
    '''

This element gets added as type an element type `Input` at the path `ExamplePackage.ExampleModel.component`. This description also has a `componentParam=5`. This is unpacked as a modifier with an 'instance path' of `component.componentParam`. See the modifier section for more details.

4. `parameter String id = "An example assignment"`

This element gets added to the type store as type `Input` at the path `ExamplePackage.ExampleModel.id`. The `Input` param 'value' gets assigned as a simple expression.

#### Export Format

Each element can be exported in a serializable format called `TemplateInput` format by calling `getInputs` on the element. This will return the element and all child elements of that element (recursive!) in a format easier to format into the final linkage schema `Option` or `ScheduleOption` format.

### Template

The template class serves two purposes:

1. Hold logic around grouping parser elements into a cohesive 'template'
2. Mapping `TemplateInput`s to linkage schema.

### Linkage Schema

Refer to the [linkage-schema.md doc](../../../docs/linkage-schema.md)

## Modifiers

Modifiers are a broad construct in modelica-json that encompasses all assignments. Any place with an `=` sign (including annotations) will result in the generation of a `Modification`. There is an internal representation and then a serializable format.

### Internal Use

Modifiers have the following parameters:

```typescript
class Modifier {
    name: string;
    value: any;
    modelicaPath: string;
    modifiers: Modifier[];
    redeclare: boolean;
    final: boolean;
}
```

```modelica
parameter Boolean have_sen=true
    "Set to true for sensor, false for direct pass through"
    annotation (Evaluate=true, Dialog(group="Configuration"));
```

The above snippet creates several modifications.

The assignement `have_sen=true` creates a modifier. `modelicaPath` is `have_sen`.

The annotation creates multiple modifiers:

- Modifier with name of `annotation`.
- That modifier has nested modifiers `Evaluate`, and `Dialog`
- `Dialog` has nested modifiers `Group` with a value of `configuration`

The modification object is used throughout the parser where it attempts to do context aware behaviors. For example:
- modifications generated from an annotation are typically separated out
- A `choices` definition is separated out and explicitly separated into the defined component choices
- The `have_sen` modifier is used to assign `value` for the parser `Element`

### Linkage Schema Representation

The template class 'flattens' all modifiers that have an assigned `modelicaPath` (instance path) into the following shape:

```typescript
{[key: modelicaPath]: {expression: Expression, final: boolean}}
```

If you have the following parameter declaration:

```modelica
Buildings.Templates.Components.Sensors.DifferentialPressure pAirSup_rel(
    redeclare final package Medium = MediumAir,
    final have_sen=true)
    "Duct static pressure sensor";
```

It creates the following dictionary of modifiers on the option `Buildings.Templates.AirHandlersFans.VAVMultiZone.pAirSup_rel`:

```json

{
    "modelicaPath": "Buildings.Templates.AirHandlersFans.VAVMultiZone.pAirSup_rel"
    "modifiers": {
        "Buildings.Templates.Components.Interfaces.PartialSensor.have_sen": {
          "expression": {
            "operator": "none",
            "operands": [
              true
            ]
        },
        "final": true
    }
}
```

## Loading Modelica-JSON
In [parser.ts](./parser.ts) `loadPackage` wwill attemp to load the provided path.

### Template Entry Points
The template discovery process relies on a grep for the following hierarchical class annotations:

- `__ctrlFlow(routing="root")`: Marks the top-level package containing all templates, e.g.,
`Buildings.Templates`
- `__ctrlFlow(routing="template")`: Marks individual template classes, e.g.,
`Buildings.Templates.AirHandlersFans.VAVMultiZone`

All template classes, and all packages between the root package and the template classes
are considered as "entry points" and added to the `templateNodes` array of [loader.ts](./loader.ts).
This means that the class URI ultimately dictates the explorer tree structure,
starting from the "root" package which must be unique inside a library.

Based on their URIs, the entry points are loaded in [parser.ts](./parser.ts) into
`File` instances, which starts the process of consuming modelica JSON and generating
various types of parsed `Element`s.

### Type Store
During the process of creating `Element`s, each element gets registered to a typestore using the modelica path.

If an `Element` indicates that it is a type not currently in the TypeStore, it attempts to find the file and load it.

**The type store attempts to expand any relative paths**.

Modelica supports relative pathing in multiple ways. The typestore generates a list of possible paths and iterates through the list in an attempt to find the file. The order of this list is meant to match modelicas priority order for search.

### Loader

The loader is used for package loading, but also for the lazy loading of types. When a type is provided, the loader attempts to take care of the fact that defintions can be nested:

>"A.Nested.Model.Path"

Could be found at `A/Nested/Model/Path.mo` OR `A/Nested/Model.mo` with `Path` defined inside of `Model`, etc.

### MODELICAPATH

There is an implementation of the `MODELICAPATH` concept in [loader.ts](./loader.ts) to allow searching multiple packages for a type definitions.

## TODO

### Modelica Standard Library
Currently data is NOT being pulled in from the Modelica Standard Library. A simple filter in [loader.ts](./loader.ts) is preventing loading files from the Modelica Standard Library.

### Modifiers
It is likely a good idea to try and separate out 'Modifier' like objects that have a modelicaPath vs. those that do not. `redeclare` and `final` only relate to modifiers that have a `modelicaPath`.

### Template Entry Points
The UI doesn't currently support multiple subpackages. Therefore, only the
parent package of each template class is used to generate the tree structure in the UI.
See the function `_extractSystemTypes` in [template.ts](./template.ts).
