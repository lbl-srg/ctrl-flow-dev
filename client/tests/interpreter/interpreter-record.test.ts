import { TemplateInterface, OptionInterface } from "../../src/data/template";
import {
  ConfigContext,
  resolveToValue,
  evaluate,
  resolvePaths,
} from "../../src/interpreter/interpreter";

import { ConfigInterface } from "../../src/data/config";
import { ConfigValues } from "../../src/utils/modifier-helpers";

import {
  _formatDisplayOption,
  _formatDisplayGroup,
  _formatDisplayItem,
} from "../../src/interpreter/display-option";

import { createSelections } from "./interpreter.test-utils";

/**
 * Options generated from server/tests/static-data/TestRecord.json via server parser.
 * This file is generated by running:
 *   cd server && npx jest -t "Record Binding Modifications"
 */
const testRecordOptions: {
  [key: string]: OptionInterface;
} = require("../data/options-TestRecord.json");

const testRecordTemplate: TemplateInterface = {
  modelicaPath: "TestRecord",
  name: "TestRecord",
  systemTypes: [],
  pathModifiers: {},
};

// Mock config for testing
const mockConfig = {
  id: "test-config",
  name: "Test Config",
  templatePath: "TestRecord",
  selections: {},
};

/**
 * Heat pump plant test data loaded from gzipped templates.json.
 * This file includes the plant template (Buildings.Templates.Plants.HeatPumps.AirToWater)
 * which is not yet in production but needed for testing record binding functionality.
 * Should be replaced by actual data from client/src/data/templates.json once the plant template is in production
 */
import * as zlib from "zlib";
import * as fs from "fs";
import * as path from "path";

const templatesData = JSON.parse(
  zlib
    .gunzipSync(
      fs.readFileSync(path.join(__dirname, "../data/templates.json.gz")),
    )
    .toString(),
);

const plantTemplatePath = "Buildings.Templates.Plants.HeatPumps.AirToWater";
const plantTemplate = templatesData.templates.find(
  (t: TemplateInterface) => t.modelicaPath === plantTemplatePath,
);
const plantOptions: { [key: string]: OptionInterface } = {};
templatesData.options.forEach(
  (o: OptionInterface) => (plantOptions[o.modelicaPath] = o),
);

// Mock config factory for plant tests
const createPlantConfig = (
  name: string,
  selections: ConfigValues = {},
): ConfigInterface =>
  ({
    id: `plant-config-${name}`,
    name,
    templatePath: plantTemplate.modelicaPath,
    selections: createSelections(selections),
    isLocked: false,
    systemPath: "Buildings.Templates.Plants.HeatPumps",
  }) as ConfigInterface;

const plantConfig = createPlantConfig("HP Plant");

describe("Evaluation succeeds with record bindings", () => {
  let context: ConfigContext;

  beforeAll(() => {
    context = new ConfigContext(
      testRecordTemplate,
      mockConfig as any,
      testRecordOptions,
      {},
    );

    // Log context.mods for debugging
    // console.log("context.mods:", JSON.stringify(context.mods, null, 2));

    expect(context).toBeDefined();
  });

  it("resolveToValue handles record components", () => {
    expect(resolveToValue("localRec.p", context, "mod1")).toBe(1);
  });

  it("resolveToValue handles record redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod")).toBe(0);
  });

  it("resolveToValue handles composite (record) binding", () => {
    expect(resolveToValue("localRec.p", context, "mod")).toBe(0);
    expect(resolveToValue("localRec.p", context, "mod2")).toBe(1);
  });

  it("resolveToValue handles composite (record) bindings with redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod1")).toBe(1);
  });

  it("resolveToValue handles nested record bindings", () => {
    expect(resolveToValue("mod.rec.p", context, "nes")).toBe(3);
  });

  it("resolveToValue handles nested record bindings in extends clause", () => {
    expect(resolveToValue("localRec.p", context, "nesExt")).toBe(4);
    expect(resolveToValue("mod.rec.p", context, "nesExt")).toBe(4);
    expect(resolveToValue("mod.localRec.p", context, "nesExt")).toBe(4);
  });

  it("resolveToValue handles deep-nested bindings in extends clause", () => {
    expect(resolveToValue("mod1.localRec.p", context, "nesExt1")).toBe(-3);
    expect(resolveToValue("mod1.rec.p", context, "nesExt1")).toBe(-3);
  });
});

describe("Record bindings in real-world plant template", () => {
  it("ctl.cfg.have_chiWat should be false when have_chiWat is false", () => {
    let context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    // Verify enable expression evaluates to true when have_chiWat is true (default)
    expect(resolveToValue("cfg.have_chiWat", context, "ctl")).toBe(true);

    const selections = {
      "Buildings.Templates.Plants.HeatPumps.Interfaces.PartialHeatPumpPlant.have_chiWat-have_chiWat": false,
    };

    const configWithSelections = createPlantConfig(
      "HP Plant - heating only",
      selections,
    );

    context = new ConfigContext(
      plantTemplate as TemplateInterface,
      configWithSelections,
      plantOptions,
      createSelections(selections),
    );

    expect(resolveToValue("cfg.have_chiWat", context, "ctl")).toBe(false);
  });

  it("should disable ctl.have_senTChiWatSecRet_select if have_chiWat is false", () => {
    let context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    const enableExpr = context?.getOptionInstance(
      "ctl.have_senTChiWatSecRet_select",
    )?.option.enable;

    // Verify enable expression evaluates to true when have_chiWat is true (default)
    expect(evaluate(enableExpr, context, "ctl")).toBe(true);

    const selections = {
      "Buildings.Templates.Plants.HeatPumps.Interfaces.PartialHeatPumpPlant.have_chiWat-have_chiWat": false,
    };

    const configWithSelections = createPlantConfig(
      "HP Plant - heating only 2",
      selections,
    );

    context = new ConfigContext(
      plantTemplate as TemplateInterface,
      configWithSelections,
      plantOptions,
      createSelections(selections),
    );

    // Verify enable expression evaluates to false when have_chiWat = false
    const enableResult = evaluate(enableExpr, context, "ctl");
    expect(enableResult).toBe(false);
  });
});

describe("Path rewriting for record bindings", () => {
  it("Has ctl.cfg modifier that binds to cfg", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    // ctl.cfg has a modifier binding it to cfg (via PartialHeatPumpPlant.cfg)
    // The modifier should exist in context.mods
    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();
    expect(ctlCfgMod.expression.operator).toBe("none");
    // The binding points to cfg
    expect(ctlCfgMod.expression.operands[0]).toBe("cfg");
  });

  it("Path resolution rewrites instance path when recordBinding is true", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.have_heaWat
    const { optionPath, instancePath } = resolvePaths(
      "ctl.cfg.have_heaWat",
      context,
    );

    // The option path should point to the Configuration.HeatPumpPlant.have_heaWat
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("have_heaWat");

    // The instance path should be rewritten from ctl.cfg.have_heaWat to cfg.have_heaWat
    expect(instancePath).toBe("cfg.have_heaWat");
  });

  it("Record binding rewrites instance path for nested typ field", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.typ
    const { optionPath, instancePath } = resolvePaths("ctl.cfg.typ", context);

    // The option path should point to the Configuration.HeatPumpPlant.typ
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("typ");

    // The instance path should be rewritten from ctl.cfg.typ to cfg.typ
    expect(instancePath).toBe("cfg.typ");
  });

  it("Record binding rewrites instance path for nHp field", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig,
      plantOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.nHp
    const { optionPath, instancePath } = resolvePaths("ctl.cfg.nHp", context);

    // The option path should point to the Configuration.HeatPumpPlant.nHp
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("nHp");

    // The instance path should be rewritten from ctl.cfg.nHp to cfg.nHp
    expect(instancePath).toBe("cfg.nHp");
  });
});
