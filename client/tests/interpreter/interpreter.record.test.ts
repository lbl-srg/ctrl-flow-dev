import { TemplateInterface, OptionInterface } from "../../src/data/template";
import {
  ConfigContext,
  resolveToValue,
  evaluate,
  resolvePaths,
} from "../../src/interpreter/interpreter";

import RootStore from "../../src/data";
import { ConfigInterface } from "../../src/data/config";
import { ConfigValues } from "../../src/utils/modifier-helpers";

import {
  _formatDisplayOption,
  _formatDisplayGroup,
  _formatDisplayItem,
} from "../../src/interpreter/display-option";

/**
 * Options generated from server/tests/static-data/TestRecord.json via server parser.
 * This file is generated by running:
 *   cd server && npx jest -t "Record Binding Modifications"
 */
const testRecordOptions: {
  [key: string]: OptionInterface;
} = require("../data/options-TestRecord.json");

const testRecordTemplate: TemplateInterface = {
  modelicaPath: "TestRecord",
  name: "TestRecord",
  systemTypes: [],
  pathModifiers: {},
};

// Mock config for testing
const mockConfig = {
  id: "test-config",
  name: "Test Config",
  templatePath: "TestRecord",
  selections: {},
};

// initialize global test dependencies
const store = new RootStore();
const plantTemplatePath = "Buildings.Templates.Plants.HeatPumps.AirToWater";
const allOptions: { [key: string]: OptionInterface } =
  store.templateStore.getAllOptions();
const allTemplates: { [key: string]: TemplateInterface } =
  store.templateStore.getAllTemplates();
const plantTemplate = allTemplates[plantTemplatePath];

const createSelections = (selections: ConfigValues = {}) => {
  return {
    ...selections,
  };
};

const addNewConfig = (
  configName: string,
  template: TemplateInterface,
  selections: ConfigValues,
) => {
  store.configStore.add({
    name: configName,
    templatePath: template.modelicaPath,
  });

  const configWithSelections = store.configStore.configs.find(
    (c) => c.name === configName,
  ) as ConfigInterface;

  const selectionsWithProjectSelections = createSelections(selections);

  store.configStore.setSelections(
    configWithSelections.id,
    selectionsWithProjectSelections,
  );

  return configWithSelections;
};

const plantConfig = addNewConfig("HP Plant", plantTemplate, {});

describe("Record Binding Interpreter Tests", () => {
  let context: ConfigContext;

  beforeAll(() => {
    context = new ConfigContext(
      testRecordTemplate,
      mockConfig as any,
      testRecordOptions,
      {},
    );

    // Log context.mods for debugging
    console.log("context.mods:", JSON.stringify(context.mods, null, 2));
  });

  it("Creates a valid context", () => {
    expect(context).toBeDefined();
  });

  it("Modifier without binding has recordBinding=false", () => {
    const modOption = testRecordOptions["TestRecord.Mod"];
    const recModifier = modOption.modifiers["TestRecord.BaseModel.rec"];

    expect(recModifier).toBeDefined();
    // After refactoring: redeclare stores the actual type, not a boolean
    expect(recModifier.redeclare).toBe("TestRecord.Rec");
    expect(recModifier.recordBinding).toBe(false);
  });

  it("resolveToValue handles record components", () => {
    expect(resolveToValue("localRec.p", context, "mod1")).toBe(1);
  });

  it("resolveToValue handles record redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod")).toBe(0);
  });

  it("resolveToValue handles composite (record) binding", () => {
    expect(resolveToValue("localRec.p", context, "mod")).toBe(0);
    expect(resolveToValue("localRec.p", context, "mod2")).toBe(1);
  });

  it("resolveToValue handles composite (record) bindings with redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod1")).toBe(1);
  });

  it("resolveToValue handles nested record bindings", () => {
    expect(resolveToValue("mod.rec.p", context, "nes")).toBe(3);
  });

  it("resolveToValue handles nested record bindings in extends clause", () => {
    expect(resolveToValue("localRec.p", context, "nesExt")).toBe(4);
    expect(resolveToValue("mod.rec.p", context, "nesExt")).toBe(4);
    expect(resolveToValue("mod.localRec.p", context, "nesExt")).toBe(4);
  });
});

describe("Test plant template", () => {
  it("ctl.cfg.have_chiWat should be false when have_chiWat is false", () => {
    let context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    // Verify enable expression evaluates to true when have_chiWat is true (default)
    expect(resolveToValue("cfg.have_chiWat", context, "ctl")).toBe(true);

    const configName = "HP Plant - heating only";
    const selections = {
      "Buildings.Templates.Plants.HeatPumps.Interfaces.PartialHeatPumpPlant.have_chiWat-have_chiWat": false,
    };

    const configWithSelections = addNewConfig(
      configName,
      plantTemplate,
      selections,
    );

    context = new ConfigContext(
      plantTemplate as TemplateInterface,
      configWithSelections as ConfigInterface,
      allOptions,
      selections,
    );

    expect(resolveToValue("cfg.have_chiWat", context, "ctl")).toBe(false);
  });

  it("should disable ctl.have_senTChiWatSecRet_select if have_chiWat is false", () => {
    let context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    const enableExpr = context?.getOptionInstance(
      "ctl.have_senTChiWatSecRet_select",
    )?.option.enable;

    // Verify enable expression evaluates to true when have_chiWat is true (default)
    expect(evaluate(enableExpr, context, "ctl")).toBe(true);

    const configName = "HP Plant - heating only 2";
    const selections = {
      "Buildings.Templates.Plants.HeatPumps.Interfaces.PartialHeatPumpPlant.have_chiWat-have_chiWat": false,
    };

    const configWithSelections = addNewConfig(
      configName,
      plantTemplate,
      selections,
    );

    context = new ConfigContext(
      plantTemplate as TemplateInterface,
      configWithSelections as ConfigInterface,
      allOptions,
      selections,
    );

    // Verify enable expression evaluates to false when have_chiWat = false
    const enableResult = evaluate(enableExpr, context, "ctl");
    expect(enableResult).toBe(false);
  });
});

describe("Record binding tests", () => {
  it("Has ctl.cfg modifier that binds to cfg", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    // ctl.cfg has a modifier binding it to cfg (via PartialHeatPumpPlant.cfg)
    // The modifier should exist in context.mods
    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();
    expect(ctlCfgMod.expression.operator).toBe("none");
    // The binding points to PartialHeatPumpPlant.cfg which resolves to the cfg instance
    expect(ctlCfgMod.expression.operands[0]).toBe(
      "Buildings.Templates.Plants.HeatPumps.Interfaces.PartialHeatPumpPlant.cfg",
    );
  });

  it("Path resolution rewrites instance path when recordBinding is true", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.have_heaWat
    const { optionPath, instancePath } = resolvePaths(
      "ctl.cfg.have_heaWat",
      context,
    );

    // The option path should point to the Configuration.HeatPumpPlant.have_heaWat
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("have_heaWat");

    // The instance path should be rewritten from ctl.cfg.have_heaWat to cfg.have_heaWat
    expect(instancePath).toBe("cfg.have_heaWat");
  });

  it("Record binding rewrites instance path for nested typ field", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.typ
    const { optionPath, instancePath } = resolvePaths("ctl.cfg.typ", context);

    // The option path should point to the Configuration.HeatPumpPlant.typ
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("typ");

    // The instance path should be rewritten from ctl.cfg.typ to cfg.typ
    expect(instancePath).toBe("cfg.typ");
  });

  it("Record binding rewrites instance path for nHp field", () => {
    const context = new ConfigContext(
      plantTemplate as TemplateInterface,
      plantConfig as ConfigInterface,
      allOptions,
      createSelections(),
    );

    const ctlCfgMod = context.mods["ctl.cfg"];
    expect(ctlCfgMod).toBeDefined();

    // Resolve path for ctl.cfg.nHp
    const { optionPath, instancePath } = resolvePaths("ctl.cfg.nHp", context);

    // The option path should point to the Configuration.HeatPumpPlant.nHp
    expect(optionPath).toBeDefined();
    expect(optionPath).toContain("nHp");

    // The instance path should be rewritten from ctl.cfg.nHp to cfg.nHp
    expect(instancePath).toBe("cfg.nHp");
  });
});
