import { TemplateInterface, OptionInterface } from "../../src/data/template";
import {
  ConfigContext,
  resolveToValue,
  evaluate,
} from "../../src/interpreter/interpreter";

/**
 * Options generated from server/tests/static-data/TestRecord.json via server parser.
 * This file is generated by running:
 *   cd server && npm test -- --testPathPattern="modifiers.test" --testNamePattern="Record Binding"
 */
const testRecordOptions: {
  [key: string]: OptionInterface;
} = require("../data/options-TestRecord.json");

const testRecordTemplate: TemplateInterface = {
  modelicaPath: "TestRecord",
  name: "TestRecord",
  systemTypes: [],
  pathModifiers: {},
};

// Mock config for testing
const mockConfig = {
  id: "test-config",
  name: "Test Config",
  templatePath: "TestRecord",
  selections: {},
};

describe("Record Binding Interpreter Tests", () => {
  let context: ConfigContext;

  beforeAll(() => {
    context = new ConfigContext(
      testRecordTemplate,
      mockConfig as any,
      testRecordOptions,
      {},
    );

    // Log context.mods for debugging
    console.log("context.mods:", JSON.stringify(context.mods, null, 2));
  });

  it("Creates a valid context", () => {
    expect(context).toBeDefined();
  });

  it("Modifier without binding has recordBinding=false", () => {
    const modOption = testRecordOptions["TestRecord.Mod"];
    const recModifier = modOption.modifiers["TestRecord.BaseModel.rec"];

    expect(recModifier).toBeDefined();
    expect(recModifier.redeclare).toBe(true);
    expect(recModifier.recordBinding).toBe(false);
  });

  it("resolveToValue handles record components", () => {
    expect(resolveToValue("localRec.p", context, "mod1")).toBe(1);
  });

  it("resolveToValue handles record redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod")).toBe(0);
  });

  it("resolveToValue handles composite (record) binding", () => {
    expect(resolveToValue("localRec.p", context, "mod")).toBe(0);
    expect(resolveToValue("localRec.p", context, "mod2")).toBe(1);
  });

  it("resolveToValue handles composite (record) bindings with redeclaration", () => {
    expect(resolveToValue("rec.p", context, "mod1")).toBe(1);
  });
});
